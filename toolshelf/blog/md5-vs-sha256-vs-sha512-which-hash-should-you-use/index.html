<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Primary Meta Tags -->
    <title>MD5 vs SHA256 vs SHA512: Which Hash Should You Use? | ToolShelf Blog</title>
    <meta name="title" content="MD5 vs SHA256 vs SHA512: Which Hash Should You Use?">
    <meta name="description" content="Complete comparison of MD5, SHA256, and SHA512 hash algorithms. Learn security levels, performance differences, and when to use each algorithm in 2025.">

    <!-- Canonical URL -->
    <link rel="canonical" href="https://toolshelf.tech/blog/md5-vs-sha256-vs-sha512-which-hash-should-you-use/">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://toolshelf.tech/blog/md5-vs-sha256-vs-sha512-which-hash-should-you-use/">
    <meta property="og:title" content="MD5 vs SHA256 vs SHA512: Which Hash Should You Use?">
    <meta property="og:description" content="Complete comparison of MD5, SHA256, and SHA512 hash algorithms. Learn security levels, performance differences, and when to use each algorithm in 2025.">
    <meta property="og:image" content="https://toolshelf.tech/assets/images/blog-cover-hash-comparison.png">

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://toolshelf.tech/blog/md5-vs-sha256-vs-sha512-which-hash-should-you-use/">
    <meta property="twitter:title" content="MD5 vs SHA256 vs SHA512: Which Hash Should You Use?">
    <meta property="twitter:description" content="Complete comparison of MD5, SHA256, and SHA512 hash algorithms. Learn security levels, performance differences, and when to use each algorithm in 2025.">
    <meta property="twitter:image" content="https://toolshelf.tech/assets/images/blog-cover-hash-comparison.png">

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="../../favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png">
    <link rel="manifest" href="../../manifest.json">
    <meta name="theme-color" content="#3b82f6">

    <!-- CSS -->
    <link rel="stylesheet" href="../../shared/css/variables.css">
    <link rel="stylesheet" href="../../shared/css/base.css">
    <link rel="stylesheet" href="../../shared/css/layout.css">
    <link rel="stylesheet" href="../css/blog.css">

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Prism.js for Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
</head>

<body>
    <div class="scroll-progress-bar"></div>

    <header class="app-header">
        <div class="header-container">
            <div class="logo-section">
                <div class="logo-icon">
                    <i class="fas fa-toolbox"></i>
                </div>
                <a href="../../" class="logo-text">ToolShelf</a>
            </div>
            <nav class="main-nav">
                <a href="../../" class="nav-link">Home</a>
                <a href="../../#tools" class="nav-link">Tools</a>
                <a href="../" class="nav-link active">Blog</a>
                <a href="../../#about" class="nav-link">About</a>
            </nav>
            <div class="header-actions">
                <button class="theme-switcher-btn" id="themeSwitcher" title="Switch to dark mode" aria-label="Switch to dark mode">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </header>

    <main>
        <div class="blog-post-container">
            <aside class="toc-container" id="tocContainer">
                <h3>Table of Contents</h3>
                <ul class="toc-list" id="tocList"></ul>
            </aside>
            <article class="blog-post-article">
                <header class="blog-post-header">
                    <h1 class="blog-post-title">MD5 vs SHA256 vs SHA512: Which Hash Should You Use?</h1>
                    <div class="blog-post-meta">
                        <span>By The ToolShelf Team</span>
                        <span><i class="fas fa-calendar-alt"></i> September 12, 2025</span>
                        <span><i class="fas fa-clock"></i> 8 min read</span>
                    </div>
                    <div class="blog-post-tags">
                        <span class="tag-badge">Cryptography</span>
                        <span class="tag-badge">Security</span>
                        <span class="tag-badge">Hash Functions</span>
                        <span class="tag-badge">MD5</span>
                        <span class="tag-badge">SHA256</span>
                        <span class="tag-badge">SHA512</span>
                    </div>
                </header>

                <div class="blog-post-content" id="articleContent">
                    <p>Choosing the right hash algorithm can make or break your application's security. With MD5 still appearing in legacy systems, SHA256 dominating modern applications, and SHA512 promising maximum security, developers face a critical decision that affects both security and performance.</p>

                    <p>This comprehensive comparison will help you understand when to use each algorithm, their security implications, and performance trade-offs in real-world scenarios.</p>

                    <img src="../assets/images/security-level-infographic.png" alt="Infographic showing three columns with MD5, SHA256, and SHA512 logos/icons, with security levels (broken, high, maximum) and performance indicators (fast, moderate, slower)" style="width:100%; border-radius:8px; margin:20px 0;">
                    <figcaption style="text-align: center; font-size: 0.9em; color: #666; margin-bottom: 20px;">Figure 1: Hash Algorithm Security and Performance Overview</figcaption>


                    <h2 id="the-fundamental-differences">The Fundamental Differences</h2>
                    
                    <h3>Hash Length and Output</h3>
                    <p>The most visible difference between these algorithms is their output length:</p>

                    <pre><code class="language-javascript">// MD5 - 128-bit hash (32 hex characters)
"5d41402abc4b2a76b9719d911017c592"

// SHA256 - 256-bit hash (64 hex characters)  
"2cf24dba4f21d4288094c47b3e4b1a4dd4a8f1b8e5a3b9e4c7b2c6d8a1f2e3d4"

// SHA512 - 512-bit hash (128 hex characters)
"9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"
</code></pre>

                    <h3>Algorithm Families</h3>
                    <ul>
                        <li><strong>MD5</strong>: Part of the MD (Message-Digest) family, designed in 1991</li>
                        <li><strong>SHA256</strong>: Part of SHA-2 family, published by NIST in 2001</li>
                        <li><strong>SHA512</strong>: Also SHA-2 family, same publication but different internal structure</li>
                    </ul>

                    <h2 id="security-analysis">Security Analysis</h2>

                    <h3>MD5: The Broken Algorithm</h3>
                    <p>MD5 is cryptographically broken and should not be used for security purposes. Here's why:</p>

                    <ul>
                        <li><strong>Collision attacks</strong>: Two different inputs can produce the same hash</li>
                        <li><strong>Preimage attacks</strong>: Possible to find input that produces a specific hash</li>
                        <li><strong>Speed vulnerabilities</strong>: Too fast, making brute force attacks feasible</li>
                    </ul>

                    <p>Despite these vulnerabilities, MD5 still has legitimate uses:</p>

                    <pre><code class="language-javascript">// Acceptable MD5 uses in 2025
const acceptableUses = {
  fileChecksum: "Detecting accidental corruption (not tampering)",
  cacheKeys: "Non-cryptographic hash table keys", 
  legacySupport: "Maintaining compatibility with old systems",
  performanceTest: "Benchmarking hash performance baselines"
};

// NEVER use MD5 for these
const dangerousUses = {
  passwords: "Easily cracked with rainbow tables",
  digitalSignatures: "Vulnerable to collision attacks",
  certificates: "All major browsers reject MD5 certificates", 
  apiAuthentication: "Trivial to forge"
};
</code></pre>

                    <h3>SHA256: The Industry Standard</h3>
                    <p>SHA256 represents the sweet spot for most applications:</p>

                    <ul>
                        <li><strong>No known practical attacks</strong></li>
                        <li><strong>Widely supported</strong> across all platforms and languages</li>
                        <li><strong>Approved by NIST</strong> and other standards bodies</li>
                        <li><strong>Used by Bitcoin</strong> and major cryptocurrencies</li>
                        <li><strong>Performance optimized</strong> in most modern CPUs</li>
                    </ul>

                    <pre><code class="language-javascript">// Real-world SHA256 applications
const sha256Uses = {
  blockchain: "Bitcoin, Ethereum proof-of-work",
  certificates: "TLS/SSL certificate signatures", 
  passwords: "Secure password hashing (with salt)",
  fileIntegrity: "Software distribution checksums",
  apiKeys: "Secure API token generation",
  digitalSignatures: "Document and code signing"
};
</code></pre>

                    <h3>SHA512: Maximum Security</h3>
                    <p>SHA512 offers the highest security level but comes with trade-offs:</p>

                    <ul>
                        <li><strong>Larger hash size</strong> provides more entropy</li>
                        <li><strong>Better resistance</strong> to future quantum attacks</li>
                        <li><strong>Slower performance</strong> on 32-bit systems</li>
                        <li><strong>Higher storage requirements</strong> for hash values</li>
                    </ul>

                    <img src="../assets/images/security-comparison-chart.png" alt="Security comparison chart showing attack resistance levels for MD5 (multiple vulnerabilities), SHA256 (high security), and SHA512 (maximum security) with visual security meters" style="width:100%; border-radius:8px; margin:20px 0;">
                    <figcaption style="text-align: center; font-size: 0.9em; color: #666; margin-bottom: 20px;">Figure 2: Security Comparison of MD5, SHA256, and SHA512</figcaption>

                    <h2 id="performance-benchmarks">Performance Benchmarks</h2>

                    <p>Performance varies significantly based on hardware and implementation. Here's what you can expect:</p>

                    <h3>Speed Comparison</h3>
                    <pre><code class="language-javascript">// Approximate throughput (MB/s) on modern hardware
const performanceBaseline = {
  md5: {
    cpu: "~500-800 MB/s",
    use_case: "Legacy file checksums",
    efficiency: "Fastest, but insecure"
  },
  
  sha256: {
    cpu: "~100-300 MB/s", 
    hardware_acceleration: "~1000+ MB/s (with AES-NI)",
    use_case: "General cryptographic applications",
    efficiency: "Good balance of speed and security"
  },
  
  sha512: {
    cpu_32bit: "~80-150 MB/s (slower on 32-bit)",
    cpu_64bit: "~120-400 MB/s (faster on 64-bit)", 
    use_case: "High-security applications",
    efficiency: "Slower but maximum security"
  }
};
</code></pre>

                    <h3>When Performance Matters</h3>
                    <p>Consider these scenarios when choosing based on performance:</p>

                    <ul>
                        <li><strong>High-frequency operations</strong>: Session token generation, API rate limiting</li>
                        <li><strong>Large file processing</strong>: Software distribution, backup verification</li>
                        <li><strong>Embedded systems</strong>: IoT devices with limited CPU resources</li>
                        <li><strong>Real-time applications</strong>: Gaming, live streaming authentication</li>
                    </ul>

                    <h2 id="practical-decision-guide">Practical Decision Guide</h2>

                    <h3>Choose MD5 When:</h3>
                    <ul>
                        <li>You need the fastest possible hashing for non-security purposes</li>
                        <li>Working with legacy systems that require MD5 compatibility</li>
                        <li>Creating simple file checksums for corruption detection</li>
                        <li>Generating cache keys or hash table indices</li>
                    </ul>

                    <pre><code class="language-javascript">// Safe MD5 usage example
function generateCacheKey(data) {
  // Safe: Using MD5 for non-cryptographic cache key
  return crypto.createHash('md5')
    .update(JSON.stringify(data))
    .digest('hex');
}

// Detect file corruption (not tampering)
function quickFileChecksum(buffer) {
  return crypto.createHash('md5')
    .update(buffer)
    .digest('hex');
}
</code></pre>

                    <h3>Choose SHA256 When:</h3>
                    <ul>
                        <li>Building secure applications (recommended default)</li>
                        <li>Implementing password hashing systems</li>
                        <li>Creating digital signatures or certificates</li>
                        <li>Working with blockchain or cryptocurrency</li>
                        <li>Need balance between security and performance</li>
                    </ul>

                    <pre><code class="language-javascript">// SHA256 for secure applications
function secureHash(data, salt = '') {
  return crypto.createHash('sha256')
    .update(data + salt)
    .digest('hex');
}

// File integrity verification
function verifyFileIntegrity(buffer, expectedHash) {
  const actualHash = crypto.createHash('sha256')
    .update(buffer)
    .digest('hex');
  return actualHash === expectedHash;
}
</code></pre>

                    <h3>Choose SHA512 When:</h3>
                    <ul>
                        <li>Maximum security is required</li>
                        <li>Working with highly sensitive data</li>
                        <li>Future-proofing against quantum computing</li>
                        <li>Regulatory compliance requires strongest hashing</li>
                        <li>64-bit systems where performance is acceptable</li>
                    </ul>

                    <pre><code class="language-javascript">// SHA512 for maximum security
function highSecurityHash(data, salt) {
  return crypto.createHash('sha512')
    .update(data + salt)
    .digest('hex');
}

// Secure key derivation
function deriveKey(password, salt, iterations = 100000) {
  return crypto.pbkdf2Sync(password, salt, iterations, 64, 'sha512');
}
</code></pre>

                    <h2 id="implementation-best-practices">Implementation Best Practices</h2>

                    <h3>Always Use Salt for Passwords</h3>
                    <pre><code class="language-javascript">// WRONG: Hashing passwords without salt
const badHash = crypto.createHash('sha256')
  .update(password)
  .digest('hex');

// RIGHT: Using salt and proper key derivation
const salt = crypto.randomBytes(32);
const goodHash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha256');
</code></pre>

                    <h3>Consider Hardware Acceleration</h3>
                    <pre><code class="language-javascript">// Check for hardware acceleration support
function getBestHashAlgorithm() {
  const crypto = require('crypto');
  
  // Check if AES-NI is available (improves SHA256 performance)
  if (crypto.constants && crypto.constants.OPENSSL_VERSION_NUMBER) {
    return 'sha256'; // Hardware accelerated on most modern CPUs
  }
  
  // Fallback based on CPU architecture
  const arch = process.arch;
  if (arch === 'x64') {
    return 'sha256'; // Good performance on 64-bit
  } else {
    return 'md5'; // Only if security isn't critical
  }
}
</code></pre>

                    <h3>Validate Hash Lengths</h3>
                    <pre><code class="language-javascript">function validateHashFormat(hash, expectedAlgorithm) {
  const lengths = {
    md5: 32,
    sha256: 64, 
    sha512: 128
  };
  
  const expectedLength = lengths[expectedAlgorithm];
  
  if (hash.length !== expectedLength) {
    throw new Error(`Invalid ${expectedAlgorithm} hash length`);
  }
  
  if (!/^[a-f0-9]+$/i.test(hash)) {
    throw new Error('Hash contains invalid characters');
  }
  
  return true;
}
</code></pre>

                    <h2 id="migration-strategies">Migration Strategies</h2>

                    <h3>Moving Away from MD5</h3>
                    <p>If you're currently using MD5 for security purposes, here's a safe migration path:</p>

                    <pre><code class="language-javascript">function migrateFromMD5(userData, plaintextPassword) {
  // Step 1: Verify existing MD5 hash
  const oldHash = crypto.createHash('md5')
    .update(plaintextPassword)
    .digest('hex');
    
  if (oldHash !== userData.password_hash) {
    throw new Error('Invalid credentials');
  }
  
  // Step 2: Generate new SHA256 hash with salt
  const salt = crypto.randomBytes(32);
  const newHash = crypto.pbkdf2Sync(
    plaintextPassword, 
    salt, 
    100000, 
    64, 
    'sha256'
  );
  
  // Step 3: Update database
  return {
    password_hash: newHash.toString('hex'),
    salt: salt.toString('hex'),
    algorithm: 'pbkdf2-sha256',
    iterations: 100000
  };
}
</code></pre>


                    <img src="../assets/images/migration-path-flowchart.png" alt="Flow chart showing migration path from MD5 to SHA256 to SHA512, with decision points for security requirements and performance constraints" style="width:100%; border-radius:8px; margin:20px 0;">
                    <figcaption style="text-align: center; font-size: 0.9em; color: #666; margin-bottom: 20px;">Figure 3: Migration Path from MD5 to SHA256 to SHA512</figcaption>
                    <h2 id="real-world-applications">Real-World Applications</h2>

                    <h3>Web Development</h3>
                    <pre><code class="language-javascript">// Express.js middleware for file upload integrity
function verifyUploadIntegrity(algorithm = 'sha256') {
  return (req, res, next) => {
    const expectedHash = req.headers['x-file-hash'];
    
    if (!expectedHash) {
      return res.status(400).json({ error: 'Hash header required' });
    }
    
    const actualHash = crypto.createHash(algorithm)
      .update(req.file.buffer)
      .digest('hex');
      
    if (actualHash !== expectedHash) {
      return res.status(400).json({ error: 'File integrity check failed' });
    }
    
    next();
  };
}
</code></pre>

                    <h3>Database Operations</h3>
                    <pre><code class="language-javascript">// Efficient duplicate detection using different hash algorithms
class DuplicateDetector {
  constructor() {
    this.fastHashes = new Set();    // MD5 for quick filtering
    this.secureHashes = new Set();  // SHA256 for final verification
  }
  
  isDuplicate(data) {
    // Step 1: Quick MD5 check (fast elimination)
    const fastHash = crypto.createHash('md5')
      .update(data)
      .digest('hex');
      
    if (!this.fastHashes.has(fastHash)) {
      this.fastHashes.add(fastHash);
      return false;  // Definitely not a duplicate
    }
    
    // Step 2: SHA256 verification (handle MD5 collisions)
    const secureHash = crypto.createHash('sha256')
      .update(data)
      .digest('hex');
      
    if (this.secureHashes.has(secureHash)) {
      return true;   // Confirmed duplicate
    }
    
    this.secureHashes.add(secureHash);
    return false;
  }
}
</code></pre>

                    <h2 id="testing-and-validation">Testing and Validation</h2>

                    <p>Always test your hash implementations with known values:</p>

                    <pre><code class="language-javascript">// Test vectors for validation
const testVectors = {
  input: "The quick brown fox jumps over the lazy dog",
  
  expected: {
    md5: "9e107d9d372bb6826bd81d3542a419d6",
    sha256: "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592",
    sha512: "07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb642e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6"
  }
};

function validateImplementation() {
  ['md5', 'sha256', 'sha512'].forEach(algorithm => {
    const hash = crypto.createHash(algorithm)
      .update(testVectors.input)
      .digest('hex');
      
    console.assert(
      hash === testVectors.expected[algorithm],
      `${algorithm} implementation failed validation`
    );
  });
  
  console.log('All hash implementations validated successfully');
}
</code></pre>

                    <h2 id="the-bottom-line">The Bottom Line</h2>

                    <p>Your choice of hash algorithm should align with your specific requirements:</p>

                    <ul>
                        <li><strong>For security applications</strong>: Use SHA256 as your default choice</li>
                        <li><strong>For maximum security</strong>: Choose SHA512 when protection is paramount</li>
                        <li><strong>For legacy compatibility</strong>: MD5 only for non-cryptographic purposes</li>
                        <li><strong>For performance-critical applications</strong>: Benchmark all options with your specific data</li>
                    </ul>

                    <p>Remember that security requirements evolve over time. What's secure today may not be secure tomorrow. Plan for migration paths and regularly review your cryptographic choices.</p>

                    <p>Most importantly: when in doubt, choose SHA256. It provides strong security, good performance, and wide compatibility across all modern systems.</p>

                    <hr>
                    
                    <p>
                      <em>
                        Building fast, secure tools is all about making informed trade-offs. That's the philosophy behind <a
                          href="https://toolshelf.tech">ToolShelf</a>—giving developers the utilities they need with privacy-first, offline-capable tools that keep your data secure.
                      </em>
                    </p>
                    
                    <p>Try our <a href="https://toolshelf.tech/hash-generator/">Hash Generator</a> to test MD5, SHA256, and SHA512 with your own data—completely offline and private.</p>
                    
                    <p>
                      Stay safe &amp; happy coding,<br>
                      &mdash; ToolShelf Team
                    </p>
                </div>
                
                <div class="blog-post-navigation">
                    <a href="#" id="prevPostLink" class="nav-link-post prev-post hidden">
                        <i class="fas fa-arrow-left"></i>
                        <span>Previous Post</span>
                        <span class="nav-post-title"></span>
                    </a>
                    <a href="#" id="nextPostLink" class="nav-link-post next-post hidden">
                        <span>Next Post</span>
                        <span class="nav-post-title"></span>
                        <i class="fas fa-arrow-right"></i>
                    </a>
                </div>

                <section class="related-posts-section">
                    <h2 class="section-title">Also Read</h2>
                    <div class="related-posts-grid">
                        <!-- Related posts will be injected here by JavaScript -->
                    </div>
                </section>
            </article>
        </div>
    </main>

    <footer class="app-footer">
        <div class="footer-content">
            <div class="footer-main">
                <div class="footer-logo">
                    <div class="logo-icon">
                        <i class="fas fa-toolbox"></i>
                    </div>
                    <strong>ToolShelf</strong>
                </div>
                <p class="footer-description">
                    Professional online tools that respect your privacy. Built for developers and professionals
                    worldwide.
                </p>
            </div>
            <div class="footer-links">
                <div class="footer-section">
                    <h4>Tools</h4>
                    <a href="../../json-formatter/">JSON Formatter</a>
                    <a href="../../base64-encoder/">Base64 Encoder</a>
                    <a href="../../text-transformer/">Text Transformer</a>
                    <a href="../../qr-generator/">QR Generator</a>
                    <a href="../../hash-generator/">Hash Generator</a>
                </div>
                <div class="footer-section">
                    <h4>Resources</h4>
                    <a href="../../#about">About ToolShelf</a>
                    <a href="../../privacy/">Privacy Policy</a>
                    <a href="../../terms/">Terms of Use</a>
                    <a href="../../faq/">FAQs</a>
                    <a href="../../contact/">Contact</a>
                </div>
                 <div class="footer-section">
                    <h4>Company</h4>
                    <a href="../">Blog</a>
                    <a href="../../#about">About Us</a>
                    <a href="../../contact/">Contact</a>
                </div>
            </div>
        </div>
        <div class="footer-bottom">
            <p>© 2025 ToolShelf. All tools work offline and respect your privacy.</p>
        </div>
    </footer>

    <script src="../../shared/config/constants.js"></script>
    <script src="../../shared/js/core/utils.js"></script>
    <script src="../../shared/js/core/analytics.js"></script>
    <script src="../../shared/js/core/app.js"></script>
    <script type="module" src="../js/blog-post.js"></script>
    <!-- Prism.js for Syntax Highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
    <script>
        // Minimal Theme Switcher
        (function() {
            let currentTheme = 'light';
            
            function loadTheme() {
                try {
                    const saved = localStorage.getItem('toolshelf-theme');
                    if (saved === 'dark' || saved === 'light') {
                        currentTheme = saved;
                    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                        currentTheme = 'dark';
                    }
                    document.documentElement.setAttribute('data-theme', currentTheme);
                } catch (e) {
                    document.documentElement.setAttribute('data-theme', 'light');
                }
            }
            
            function toggleTheme() {
                currentTheme = currentTheme === 'light' ? 'dark' : 'light';
                document.documentElement.setAttribute('data-theme', currentTheme);
                try {
                    localStorage.setItem('toolshelf-theme', currentTheme);
                } catch (e) {}
                updateButton();
            }
            
            function updateButton() {
                const btn = document.getElementById('themeSwitcher');
                if (btn) {
                    const icon = btn.querySelector('i');
                    const isDark = currentTheme === 'dark';
                    if (icon) {
                        icon.className = isDark ? 'fas fa-sun' : 'fas fa-moon';
                    }
                    btn.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
                    btn.setAttribute('aria-label', btn.title);
                }
            }
            
            // Load theme immediately
            loadTheme();
            
            // Setup when DOM is ready
            document.addEventListener('DOMContentLoaded', function() {
                updateButton();
                const btn = document.getElementById('themeSwitcher');
                if (btn) {
                    btn.addEventListener('click', toggleTheme);
                }
            });
        })();
    </script>
    <div id="feedbackWidgetContainer"></div>
    <script type="module">
        import { initFeedbackWidget } from '../../shared/js/core/feedback-widget.js';
        document.addEventListener('DOMContentLoaded', () => {
            initFeedbackWidget('Blog Post: ' + document.title);
        });
    </script>
</body>
</html>