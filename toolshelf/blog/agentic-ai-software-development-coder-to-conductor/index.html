<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- Primary Meta Tags --><title>Agentic AI in Software Development: From Coder to Conductor</title><meta name="title" content="Agentic AI in Software Development: From Coder to Conductor"><meta name="description" content="Explore how agentic AI is transforming software development. Learn about frameworks like AutoGen & CrewAI and the developer's new role as an AI orchestrator."><!-- Canonical URL --><link rel="canonical" href="https://toolshelf.tech/blog/agentic-ai-software-development-coder-to-conductor/"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://toolshelf.tech/blog/agentic-ai-software-development-coder-to-conductor/"><meta property="og:title" content="Agentic AI in Software Development: From Coder to Conductor"><meta property="og:description" content="Explore how agentic AI is transforming software development. Learn about frameworks like AutoGen & CrewAI and the developer's new role as an AI orchestrator."><meta property="og:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/c053529a-b883-4a08-89de-f8bf9f88fec0.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://toolshelf.tech/blog/agentic-ai-software-development-coder-to-conductor/"><meta property="twitter:title" content="Agentic AI in Software Development: From Coder to Conductor"><meta property="twitter:description" content="Explore how agentic AI is transforming software development. Learn about frameworks like AutoGen & CrewAI and the developer's new role as an AI orchestrator."><meta property="twitter:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/c053529a-b883-4a08-89de-f8bf9f88fec0.png"><!-- Favicon --><link rel="icon" type="image/x-icon" href="../../favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png"><link rel="manifest" href="../../manifest.json"><meta name="theme-color" content="#3b82f6"><!-- CSS --><link rel="stylesheet" href="../../shared/css/variables.css"><link rel="stylesheet" href="../../shared/css/base.css"><link rel="stylesheet" href="../../shared/css/layout.css"><link rel="stylesheet" href="../css/blog.css"><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><!-- Prism.js for Syntax Highlighting --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"></head><body><div class="scroll-progress-bar"></div><header class="app-header"><div class="header-container"><div class="logo-section"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><a href="../../" class="logo-text">ToolShelf</a></div><nav class="main-nav"><a href="../../" class="nav-link">Home</a><a href="../../#tools" class="nav-link">Tools</a><a href="../" class="nav-link active">Blog</a><a href="../../#about" class="nav-link">About</a></nav><div class="header-actions"><button class="theme-switcher-btn" id="themeSwitcher" title="Switch to dark mode" aria-label="Switch to dark mode"><i class="fas fa-moon"></i></button></div></div></header><main><div class="blog-post-container"><aside class="toc-container" id="tocContainer"><h3>Table of Contents</h3><ul class="toc-list" id="tocList"></ul></aside><article class="blog-post-article"><header class="blog-post-header"><h1 class="blog-post-title">Agentic AI in Software Development: From Coder to Conductor</h1><div class="blog-post-meta"><span>By The ToolShelf Team</span><span><i class="fas fa-calendar-alt"></i> September 29, 2025</span><span><i class="fas fa-clock"></i> 12 min read</span></div><div class="blog-post-tags"><span class="tag-badge">agentic ai</span><span class="tag-badge">autogen</span><span class="tag-badge">crewai</span><span class="tag-badge">automation</span><span class="tag-badge">developer tools</span></div></header><div class="blog-post-content" id="articleContent"><p>Imagine a development team that never sleeps, autonomously reviews code, generates tests, and flags potential bugs before they ever reach production. This isn't science fiction; it's the reality being built with agentic AI.</p><p>While we've grown accustomed to AI assistants that help with code completion and answer isolated questions, a new paradigm is emerging. Agentic AI systems are not just assistants; they are autonomous agents that can plan, execute, and adapt to complex, multi-step tasks. They can take a high-level goal, like 'build a new user authentication API endpoint,' and break it down into concrete steps, write the code, create the tests, and even open the pull request. This represents a fundamental shift in how we build software, moving from direct manipulation to delegated execution.</p><p>This article will guide you through the world of agentic AI, from the core concepts that separate it from traditional AI to the practical frameworks like AutoGen and CrewAI that let you build these systems today. We'll explore real-world applications transforming the development lifecycle and discuss how your role is evolving from a hands-on coder to a strategic 'orchestra conductor' of AI agents.</p><h2 id="what-is-agentic-ai-decoding-the-next-wave-of-automation">What is Agentic AI? Decoding the Next Wave of Automation</h2><h3 id="beyond-traditional-ai-defining-the-autonomous-agent">Beyond Traditional AI: Defining the Autonomous Agent</h3><p>Traditional AI assistants, like code completion tools or standard chatbots, operate on a reactive, request-response basis. You ask a question, you get an answer. You start typing, you get a suggestion. Agentic AI is fundamentally different. An AI agent is a system that can pursue a goal autonomously over multiple steps, without requiring human intervention for each action.</p><p>This autonomy is enabled by four key capabilities:</p><ul><li><strong>Goal-orientation:</strong> An agent is given a high-level objective (e.g., 'Refactor the database service to improve performance'), not just a specific command.</li><li><strong>Planning:</strong> It can decompose this goal into a sequence of executable steps (e.g., '1. Analyze current query performance. 2. Identify bottlenecks. 3. Rewrite inefficient queries. 4. Write migration script.').</li><li><strong>Memory:</strong> It maintains context from past actions, both short-term (what it just did) and long-term (accessing a knowledge base of past projects), allowing it to learn and adapt its strategy.</li><li><strong>Tool Usage:</strong> This is the most critical component. Agents can interact with the real world by using tools, which are typically functions or API calls. These tools allow an agent to read files, write code, execute shell commands, or access external services like the GitHub API.</li></ul><h3 id="the-core-loop-how-ai-agents-plan-execute-and-adapt">The Core Loop: How AI Agents Plan, Execute, and Adapt</h3><p>At the heart of most agentic systems is a continuous loop often referred to as a Reason-Act (ReAct) cycle. This workflow allows the agent to think, act, and learn dynamically.</p><p>Here’s a breakdown:</p><ol><li><strong>Decompose Goal & Plan:</strong> The agent receives a high-level objective. Using its underlying language model, it 'reasons' about the best way to achieve it and creates an initial plan.</li><li><strong>Execute Step:</strong> The agent selects the first step in its plan and chooses the appropriate tool. For example, if the step is 'Read the existing code in `auth.py`,' it will execute a `read_file` tool with the file path as an argument.</li><li><strong>Observe Outcome:</strong> The agent receives the output from the tool—either the contents of the file, an API response, or an error message.</li><li><strong>Self-Correct & Re-plan:</strong> The agent reflects on the outcome. Did it work as expected? Does this new information change the plan? If it encountered an error, it will try to debug it (e.g., 'File not found. I will try listing the directory to find the correct path.'). It then updates its plan and proceeds to the next step.</li></ol><p>This loop continues until the final goal is achieved or the agent determines it cannot proceed. In this model, the agent acts like a highly efficient project manager who can also perform all the tasks, delegate to other agents, and adapt to unforeseen challenges on the fly.</p><h3 id="why-this-is-a-game-changer-for-software-development">Why This is a Game-Changer for Software Development</h3><p>For years, automation in software development has focused on repetitive, deterministic tasks: running linters, compiling code, and executing pre-written test suites. Agentic AI shatters this limitation by enabling the automation of complex, cognitive-heavy tasks that previously required human expertise.</p><p>This marks a crucial transition from <strong>'human-in-the-loop'</strong> to <strong>'human-on-the-loop'</strong> supervision. A human-in-the-loop system requires constant human interaction and approval (e.g., accepting every GitHub Copilot suggestion). In a human-on-the-loop system, the developer sets the strategic direction, defines the constraints, and reviews the final outcome. The autonomous agents handle the entire intermediate process of planning, execution, and iteration. This frees up developers from tactical execution to focus on architecture, product strategy, and solving novel problems.</p><h2 id="the-developers-new-role-rise-of-the-ai-agent-orchestrator">The Developer's New Role: Rise of the AI Agent Orchestrator</h2><h3 id="from-writing-every-line-to-defining-the-grand-plan">From Writing Every Line to Defining the Grand Plan</h3><p>As agentic systems take over more of the tactical coding, the developer's role elevates. You are no longer just the musician playing a single instrument; you are the orchestra conductor. Your responsibility shifts from writing every line of code to designing the overall system and directing the AI agents to execute it.</p><p>Your new primary tasks include:</p><ul><li><strong>Defining Goals:</strong> Clearly articulating the desired outcome for the agent or team of agents in a way that is unambiguous and measurable.</li><li><strong>Setting Constraints:</strong> Establishing the 'rules of the road' for the agents, such as coding style guides, performance budgets, security policies, and which tools they are allowed to use.</li><li><strong>Designing Workflows:</strong> Architecting how different agents will collaborate. Who is responsible for writing code? Who handles QA? Who manages deployment? You design the assembly line, and the agents operate it.</li><li><strong>Defining Success Criteria:</strong> Specifying what 'done' looks like. This could be a set of passing tests, a successful deployment, or a performance benchmark being met.</li></ul><h3 id="skills-for-the-modern-orchestrator">Skills for the Modern Orchestrator</h3><p>This new role requires a blend of classic software engineering principles and new AI-centric skills. The most valuable orchestrators will master:</p><ul><li><strong>Systems Thinking:</strong> The ability to see the entire software development lifecycle as an interconnected system and design agent-driven workflows that optimize the whole process, not just individual tasks.</li><li><strong>Advanced Prompt Engineering:</strong> This evolves into 'Agent Instruction Design.' It's not just about a single prompt but about crafting a comprehensive persona for an agent, including its role, responsibilities, backstory, and communication style, to ensure it performs its function reliably.</li><li><strong>API Integration and Tool Creation:</strong> An agent's power is limited by its tools. A key skill is identifying which capabilities an agent needs and exposing them as robust, well-documented functions or API endpoints. If an agent needs to interact with your company's internal services, you'll be the one building that bridge.</li><li><strong>Process Design:</strong> The ability to analyze existing human-driven workflows, deconstruct them into their core components, and redesign them for autonomous AI agents.</li><li><strong>Debugging and Evaluating Agentic Systems:</strong> Debugging a non-deterministic system is a new challenge. It involves analyzing agent 'thought' logs, understanding why an agent chose a particular plan, and fine-tuning its instructions or tools to prevent future errors. Performance is measured not just by code correctness, but by the agent's autonomy, efficiency, and resource consumption.</li></ul><h2 id="your-toolkit-frameworks-for-building-collaborative-ai-agents">Your Toolkit: Frameworks for Building Collaborative AI Agents</h2><h3 id="microsoft-autogen-crafting-multi-agent-conversations">Microsoft AutoGen: Crafting Multi-Agent Conversations</h3><p>AutoGen excels at creating complex workflows through conversations between multiple agents. Its core concept is the `ConversableAgent`. You define agents that can chat with each other to solve problems. A `UserProxyAgent` can act on behalf of a human, executing code or soliciting feedback.</p><p><strong>Ideal Use Cases:</strong> Simulating collaborative team dynamics. For example, you can create a `coder_agent` that writes Python code and an `executor_agent` that runs it. The `coder_agent` proposes code, the `executor_agent` runs it and reports back the results (or errors), and the `coder_agent` iterates until the code runs successfully. This conversational back-and-forth is powerful for tasks that require refinement and feedback.</p><p><strong>Conceptual Example:</strong></p><pre><code class="language-python"># This is a conceptual example to illustrate the idea
from autogen import AssistantAgent, UserProxyAgent

# The coding agent
coder = AssistantAgent(
    name="Coder",
    llm_config=llm_config,
    system_message="You are a senior python developer. Write code to solve the user's request."
)

# The agent that executes code on behalf of the user
executor = UserProxyAgent(
    name="Executor",
    human_input_mode="NEVER",
    code_execution_config={"work_dir": "coding"}
)

# Start the conversation to solve a task
executor.initiate_chat(
    coder,
    message="Write a python script to fetch the top 5 trending topics from the ToolShelf blog API and save them to a file."
)
</code></pre><h3 id="crewai-assembling-role-based-agent-teams">CrewAI: Assembling Role-Based Agent Teams</h3><p>CrewAI is built on the philosophy of assembling a 'crew' of agents with specific, well-defined roles to tackle a mission. It provides a more structured, role-playing approach compared to AutoGen. You define `Agent`s with a `role`, `goal`, and `backstory`, equip them with `Tool`s, and assign them `Task`s. A `Crew` then orchestrates these agents to perform the tasks in a sequence or concurrently.</p><p><strong>Ideal Use Cases:</strong> Building teams that mirror real-world organizational structures. It's excellent for processes where distinct responsibilities are key. For instance, a 'Software Development Crew' can be created with agents playing the roles of a Product Manager (defining requirements), a Senior Engineer (writing code), and a QA Engineer (writing tests).</p><p><strong>Conceptual Example:</strong></p><pre><code class="language-python"># This is a conceptual example to illustrate the idea
from crewai import Agent, Task, Crew
from my_tools import file_read_tool, code_testing_tool

# Define the agents with roles and goals
senior_engineer = Agent(
  role='Senior Software Engineer',
  goal='Write clean, efficient, and well-tested code',
  backstory='You are an expert in Python with 10 years of experience.',
  tools=[file_read_tool]
)

qa_engineer = Agent(
  role='Quality Assurance Engineer',
  goal='Ensure the code is bug-free and meets all requirements',
  backstory='You have a keen eye for detail and can find any edge case.',
  tools=[code_testing_tool]
)

# Define the tasks
code_task = Task(description='Implement the fizzbuzz algorithm.', agent=senior_engineer)
test_task = Task(description='Write unit tests for the fizzbuzz implementation.', agent=qa_engineer)

# Assemble the crew and kick off the work
software_crew = Crew(agents=[senior_engineer, qa_engineer], tasks=[code_task, test_task])
result = software_crew.kickoff()
</code></pre><h3 id="microsoft-copilot-studio-low-code-enterprise-ready-agents">Microsoft Copilot Studio: Low-Code Enterprise-Ready Agents</h3><p>While AutoGen and CrewAI are code-first frameworks for developers, Microsoft Copilot Studio is an enterprise-grade, low-code platform for building and deploying agents (or 'copilots'). Its strength lies in its deep integration with the Microsoft ecosystem (Microsoft 365, Dynamics 365, Power Platform) and its focus on security, governance, and data connectivity.</p><p><strong>Ideal Use Cases:</strong> Building agents that need to interact with enterprise data and business processes. For example, you could create an agent that helps developers provision cloud resources by interacting with an internal approvals workflow in SharePoint and then using a connector to call Azure APIs. It provides a user-friendly graphical interface for designing conversation flows and connecting to data sources, while still allowing professional developers to extend its capabilities with custom code and plugins.</p><h2 id="agentic-ai-in-action-real-world-development-workflows">Agentic AI in Action: Real-World Development Workflows</h2><h3 id="use-case-1-the-autonomous-code-review-agent">Use Case 1: The Autonomous Code Review Agent</h3><p>Imagine an agent that acts as a tireless, expert reviewer on every pull request. Triggered by a GitHub webhook, this agent would perform a multi-step analysis. First, it uses a file-reading tool to ingest the code changes. It then checks the diff against a vector database containing your team's specific coding standards and best practices. Next, it uses its LLM reasoning to identify potential logical errors, security vulnerabilities (like SQL injection risks), or performance bottlenecks that simple linters would miss. Finally, it uses the GitHub API tool to post concise, actionable comments directly on the pull request, complete with code suggestions for remediation, saving the human reviewers for high-level architectural feedback.</p><h3 id="use-case-2-the-intelligent-test-generation-agent">Use Case 2: The Intelligent Test Generation Agent</h3><p>Manually writing comprehensive tests is a time-consuming but critical task. An intelligent test generation agent can automate this. Upon detecting new code pushed to a feature branch, the agent analyzes the functions and classes. It identifies the public API, understands the logic through static analysis, and generates a test plan. This plan might include creating unit tests for all public methods, generating property-based tests for edge cases, and even writing boilerplate for integration tests that require database setup. The agent then writes the test files, places them in the correct directory, and runs the test suite, providing a full report before a human even needs to look at it.</p><h3 id="use-case-3-the-seamless-deployment-orchestration-agent">Use Case 3: The Seamless Deployment Orchestration Agent</h3><p>The CI/CD pipeline is a prime candidate for agentic automation. A deployment orchestration agent can manage the entire process from commit to production. Given the goal 'Deploy version 3.5.1 to production,' the agent would create and execute a plan: 1. Use a CI tool (e.g., Jenkins API) to run the full test and build suite. 2. If successful, use a cloud provider tool (e.g., Terraform or AWS CLI) to provision or update the necessary infrastructure. 3. Use a container tool to push the new image to a registry. 4. Use a Kubernetes tool to perform a rolling update of the deployment. 5. Critically, it would then monitor application performance metrics (e.g., via Datadog API) for a set period. If it detects a spike in error rates, it automatically triggers a rollback plan, restoring the previous stable version and notifying the on-call developer with a detailed report of what went wrong.</p><h2 id="the-future-is-agentic-market-trends-and-proven-impact">The Future is Agentic: Market Trends and Proven Impact</h2><h3 id="the-tipping-point-microsoft-research-predicts-peak-interest-in-2025">The Tipping Point: Microsoft Research Predicts Peak Interest in 2025</h3><p>This isn't a far-off future; the adoption of agentic AI is accelerating rapidly. Recent research from Microsoft highlights that agentic AI is on a trajectory to move from a niche, experimental technology to a mainstream enterprise tool. Their analysis predicts that interest and adoption will reach a tipping point in 2025. By then, it is estimated that a significant portion—perhaps as many as 25%—of companies will have initiated pilot projects using agentic frameworks. This shift is driven by the demonstrable ROI in developer productivity and the increasing maturity of foundational models and frameworks, making it easier than ever to build and deploy robust agents.</p><h3 id="case-study-slashing-development-cycles-by-40">Case Study: Slashing Development Cycles by 40%</h3><p>The impact of agentic AI is not just theoretical. Consider a real-world case study from a mid-sized e-commerce company that integrated an agent-driven workflow into their feature development process. They created a 'crew' of agents to handle code generation, testing, and review for their backend services.</p><p>The results were transformative. The time saved broke down as follows:</p><ul><li><strong>Automated Test Generation:</strong> The QA agent autonomously generated unit and integration tests for new API endpoints, saving an average of 8-10 developer hours per week that were previously spent on manual test writing.</li><li><strong>Faster Code Reviews:</strong> An AI review agent handled all first-pass reviews, checking for style, common errors, and adherence to internal standards. This reduced the average time a pull request spent waiting for review from two days to just four hours, freeing up senior developers to focus on architectural decisions.</li><li><strong>Reduced Manual Overhead:</strong> A deployment agent managed the staging and release process, eliminating manual errors and reducing the time spent on deployment-related debugging by an average of 5 hours per release.</li></ul><p>Cumulatively, these efficiencies compounded to reduce their average feature development cycle—from ticket creation to production deployment—by an astounding 40%.</p><h2 id="conclusion-the-path-forward">Conclusion: The Path Forward</h2><p>Agentic AI is more than just a buzzword; it's a fundamental evolution in software development. It represents a shift from writing instructions to defining outcomes. By leveraging powerful frameworks like Microsoft's AutoGen and the role-based approach of CrewAI, developers can transition from the tactical work of writing code to the strategic role of orchestrating powerful teams of autonomous agents. These agents can automate complex, cognitive tasks across the entire development lifecycle, from ideation to deployment and maintenance.</p><p>The evidence is clear, supported by both industry research and real-world case studies: agentic systems deliver significant efficiency gains and are on the cusp of widespread adoption. For developers, the question is not <em>if</em> you will work with AI agents, but <em>when</em>. Embracing this change now allows you to shape the future of software creation, making your role more strategic, creative, and impactful than ever before.</p><p>Ready to become an orchestra conductor? Don't try to boil the ocean. Start by exploring one of the frameworks mentioned today, like CrewAI or AutoGen. Pick a small, repetitive, and well-defined task in your daily workflow—perhaps generating boilerplate code or running a pre-flight check on a pull request. Design a simple agent to automate it. The future of development is here—it's time to start building it.</p><p><em>Building secure, privacy-first tools means staying ahead of security threats. At <a href="https://toolshelf.tech">ToolShelf</a>, all operations happen locally in your browser—your data never leaves your device, providing security through isolation.</em></p><p>Stay secure &amp; happy coding,<br>&mdash; ToolShelf Team</p></div><div class="blog-post-navigation"><a href="#" id="prevPostLink" class="nav-link-post prev-post hidden"><i class="fas fa-arrow-left"></i><span>Previous Post</span><span class="nav-post-title"></span></a><a href="#" id="nextPostLink" class="nav-link-post next-post hidden"><span>Next Post</span><span class="nav-post-title"></span><i class="fas fa-arrow-right"></i></a></div><section class="related-posts-section"><h2 class="section-title">Also Read</h2><div class="related-posts-grid"></div></section></article></div></main><footer class="app-footer"><div class="footer-content"><div class="footer-main"><div class="footer-logo"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><strong>ToolShelf</strong></div><p class="footer-description">Professional online tools that respect your privacy. Built for developers and professionals worldwide.</p></div><div class="footer-links"><div class="footer-section"><h4>Tools</h4><a href="../../json-formatter/">JSON Formatter</a><a href="../../base64-encoder/">Base64 Encoder</a><a href="../../text-transformer/">Text Transformer</a><a href="../../qr-generator/">QR Generator</a><a href="../../hash-generator/">Hash Generator</a></div><div class="footer-section"><h4>Resources</h4><a href="../../#about">About ToolShelf</a><a href="../../privacy/">Privacy Policy</a><a href="../../terms/">Terms of Use</a><a href="../../faq/">FAQs</a><a href="../../contact/">Contact</a></div><div class="footer-section"><h4>Company</h4><a href="../">Blog</a><a href="../../#about">About Us</a><a href="../../contact/">Contact</a></div></div></div><div class="footer-bottom"><p>© 2025 ToolShelf. All tools work offline and respect your privacy.</p></div></footer><script src="../../shared/config/constants.js"></script><script src="../../shared/js/core/utils.js"></script><script src="../../shared/js/core/analytics.js"></script><script src="../../shared/js/core/app.js"></script><script type="module" src="../js/blog-post.js"></script><!-- Prism.js for Syntax Highlighting --><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script><script>(function () {      let currentTheme = 'light';      function loadTheme() {        try {          const saved = localStorage.getItem('toolshelf-theme');          if (saved === 'dark' || saved === 'light') {            currentTheme = saved;          } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {            currentTheme = 'dark';          }          document.documentElement.setAttribute('data-theme', currentTheme);        } catch (e) {          document.documentElement.setAttribute('data-theme', 'light');        }      }      function toggleTheme() {        currentTheme = currentTheme === 'light' ? 'dark' : 'light';        document.documentElement.setAttribute('data-theme', currentTheme);        try {          localStorage.setItem('toolshelf-theme', currentTheme);        } catch (e) { }        updateButton();      }      function updateButton() {        const btn = document.getElementById('themeSwitcher');        if (btn) {          const icon = btn.querySelector('i');          const isDark = currentTheme === 'dark';          if (icon) {            icon.className = isDark ? 'fas fa-sun' : 'fas fa-moon';          }          btn.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';          btn.setAttribute('aria-label', btn.title);        }      }      loadTheme();      document.addEventListener('DOMContentLoaded', function () {        updateButton();        const btn = document.getElementById('themeSwitcher');        if (btn) {          btn.addEventListener('click', toggleTheme);        }      });    })();</script><div id="feedbackWidgetContainer"></div><script type="module">    import { initFeedbackWidget } from '../../shared/js/core/feedback-widget.js';    document.addEventListener('DOMContentLoaded', () => {      initFeedbackWidget('Blog Post: ' + document.title);    });</script></body></html>