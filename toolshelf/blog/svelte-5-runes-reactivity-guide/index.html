<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><!-- Primary Meta Tags --><title>Svelte 5 Runes: A Developer's Guide to the Future of Reactivity</title><meta name="title" content="Svelte 5 Runes: A Developer's Guide to the Future of Reactivity"><meta name="description" content="Deep dive into Svelte 5's 'Runes' reactivity. Learn how $state, $derived, and $effect are revolutionizing frontend development with explicit, powerful state."><!-- Canonical URL --><link rel="canonical" href="https://toolshelf.tech/blog/svelte-5-runes-reactivity-guide/"><!-- Open Graph / Facebook --><meta property="og:type" content="article"><meta property="og:url" content="https://toolshelf.tech/blog/svelte-5-runes-reactivity-guide/"><meta property="og:title" content="Svelte 5 Runes: A Developer's Guide to the Future of Reactivity"><meta property="og:description" content="Deep dive into Svelte 5's 'Runes' reactivity. Learn how $state, $derived, and $effect are revolutionizing frontend development with explicit, powerful state."><meta property="og:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/7c0f79f0-ed77-4ff0-b076-31265349f055.png"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://toolshelf.tech/blog/svelte-5-runes-reactivity-guide/"><meta property="twitter:title" content="Svelte 5 Runes: A Developer's Guide to the Future of Reactivity"><meta property="twitter:description" content="Deep dive into Svelte 5's 'Runes' reactivity. Learn how $state, $derived, and $effect are revolutionizing frontend development with explicit, powerful state."><meta property="twitter:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/7c0f79f0-ed77-4ff0-b076-31265349f055.png"><!-- Favicon --><link rel="icon" type="image/x-icon" href="../../favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png"><link rel="manifest" href="../../manifest.json"><meta name="theme-color" content="#3b82f6"><!-- CSS --><link rel="stylesheet" href="../../shared/css/variables.css"><link rel="stylesheet" href="../../shared/css/base.css"><link rel="stylesheet" href="../../shared/css/layout.css"><link rel="stylesheet" href="../css/blog.css"><!-- Fonts --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><!-- Prism.js for Syntax Highlighting --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"></head><body><div class="scroll-progress-bar"></div><header class="app-header"><div class="header-container"><div class="logo-section"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><a href="../../" class="logo-text">ToolShelf</a></div><nav class="main-nav"><a href="../../" class="nav-link">Home</a><a href="../../#tools" class="nav-link">Tools</a><a href="../" class="nav-link active">Blog</a><a href="../../#about" class="nav-link">About</a></nav><div class="header-actions"><button class="theme-switcher-btn" id="themeSwitcher" title="Switch to dark mode" aria-label="Switch to dark mode"><i class="fas fa-moon"></i></button></div></div></header><main><div class="blog-post-container"><aside class="toc-container" id="tocContainer"><h3>Table of Contents</h3><ul class="toc-list" id="tocList"></ul></aside><article class="blog-post-article"><header class="blog-post-header"><h1 class="blog-post-title">Svelte 5 Runes: A Developer's Guide to the Future of Reactivity</h1><div class="blog-post-meta"><span>By The ToolShelf Team</span><span><i class="fas fa-calendar-alt"></i> September 21, 2025</span><span><i class="fas fa-clock"></i> 10 min read</span></div><div class="blog-post-tags"><span class="tag-badge">svelte</span><span class="tag-badge">javascript</span><span class="tag-badge">frontend</span><span class="tag-badge">reactivity</span><span class="tag-badge">web development</span></div></header><div class="blog-post-content" id="articleContent"><p>The world of JavaScript frameworks is in a constant state of evolution, with each new paradigm promising to solve the complexities of building for the modern web. Svelte carved its niche by turning the paradigm on its head—moving reactivity from the runtime into the compiler. This resulted in highly performant applications with remarkably little boilerplate. Now, Svelte 5 is here, and it's introducing a change that is both a natural evolution and a significant philosophical shift: Runes.</p><p>Runes are Svelte's answer to a more explicit, predictable, and powerful state management system. They move away from the 'magical' behind-the-scenes compilation that made Svelte 4 so unique, where a simple <code>let</code> declaration could become a reactive statement. While this magic was a source of delight, it also had its limitations. Runes replace this implicit behavior with explicit, function-like signals that are both instantly understandable and incredibly versatile.</p><p>This article is your comprehensive guide to Svelte 5 Runes. We'll explore why this change was necessary, break down the core primitives—<code>$state</code>, <code>$derived</code>, and <code>$effect</code>—and show you how to start using them effectively to build more robust and maintainable Svelte applications.</p><h2 id="the-why-unpacking-the-limitations-of-sveltes-old-reactivity">The 'Why': Unpacking the Limitations of Svelte's Old Reactivity</h2><p>To fully appreciate the power of Runes, it's essential to understand the problems they were designed to solve. Svelte's original compiler-based reactivity was a masterclass in developer experience for many use cases, but as applications grew in complexity, certain cracks began to show.</p><h3 id="the-magic-of-let-and-">The Magic of `let` and `$: `</h3><p>In Svelte 4 and earlier, reactivity felt like an extension of plain JavaScript. Any variable declared with `let` at the top level of a component's `<script>` block was automatically treated as reactive state. Any assignment to that variable would trigger a DOM update.</p><p>For derived state and side effects, Svelte provided the `$: ` label, also known as the 'reactive declaration'.</p><pre><code class="language-markup">&lt;script&gt;\n  let count = 0;\n\n  // This is a derived value. It re-runs whenever 'count' changes.\n  $: double = count * 2;\n\n  // This is a side effect. It also re-runs when 'count' changes.\n  $: console.log(`The count is ${count}`);\n&lt;/script&gt;</code></pre><p>For simple components, this was brilliant. It required minimal boilerplate and felt incredibly intuitive. However, this simplicity was powered by a complex compiler that instrumented your code behind the scenes. This 'magic' could sometimes become opaque, leading to confusion about what was reactive and why. For example, mutating an object or array without a direct assignment (`myArray.push(newItem)`) wouldn't trigger an update, forcing developers to use idiomatic but less direct patterns like `myArray = [...myArray, newItem]`.</p><h3 id="challenges-with-scalability-and-predictability">Challenges with Scalability and Predictability</h3><p>The compiler-driven approach hit its limits in larger, more complex applications. The most significant pain point was that reactivity was fundamentally tied to the context of a `.svelte` file. You couldn't just create a reactive primitive in a plain `.js` or `.ts` file and import it. The workaround was Svelte's store contract (`readable`, `writable`, `derived`), which, while powerful, introduced a separate API and syntax (`$storeName`) that felt disconnected from component state.</p><p>This created a cognitive divide: component state worked one way, and shared state worked another. Developers had to constantly track what was reactive versus what was plain JavaScript, a mental overhead that could lead to subtle bugs. The rules governing when a `$: ` block would re-run—only when one of its referenced variables was *assigned* to—were not always obvious, further complicating the mental model for large-scale state management.</p><h2 id="meet-the-runes-core-primitives-of-svelte-5">Meet the Runes: Core Primitives of Svelte 5</h2><p>Runes replace the compiler's implicit magic with explicit, function-based primitives. These are inspired by the concept of signals, a pattern gaining traction across frontend frameworks for its fine-grained and predictable nature. Let's meet the core trio.</p><h3 id="state-the-foundation-of-reactive-state">`$state`: The Foundation of Reactive State</h3><p>`$state` is the new cornerstone of reactivity in Svelte. It's a function that you call to create a piece of reactive state. It replaces the top-level `let` declaration for any variable that needs to trigger updates when it changes.</p><p>The key benefit is explicitness. When you see `$state`, you know you're dealing with a reactive value. Furthermore, this reactivity is no longer confined to the component scope; it can be used anywhere in your JavaScript/TypeScript code.</p><p><strong>Svelte 4:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = 0;\n\n  function increment() {\n    count += 1;\n  }\n&lt;/script&gt;</code></pre><p><strong>Svelte 5 with Runes:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n&lt;/script&gt;</code></pre><p>The syntax is simple, but the implication is huge. Reactivity is now explicitly declared, not inferred.</p><h3 id="derived-computing-values-from-state">`$derived`: Computing Values from State</h3><p>`$derived` is the Rune for creating values that are calculated from other reactive state. It is the direct and explicit replacement for the `$: ` label when used for computations.</p><p>A crucial feature of `$derived` is that it creates a memoized computation. The expression inside `$derived` will only be re-evaluated if its dependencies—the `$state` or other `$derived` values it reads—have changed. This ensures optimal performance by preventing unnecessary recalculations.</p><p><strong>Svelte 4:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = 0;\n  $: double = count * 2;\n&lt;/script&gt;</code></pre><p><strong>Svelte 5 with Runes:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = $state(0);\n  let double = $derived(count * 2);\n&lt;/script&gt;</code></pre><p>This code is not just syntactically different; it's semantically clearer. It reads as '`double` is a value derived from `count`'.</p><h3 id="effect-running-side-effects-in-response-to-changes">`$effect`: Running Side Effects in Response to Changes</h3><p>`$effect` is the Rune for running code that needs to react to state changes but doesn't produce a new value. This is for side effects: interacting with the browser APIs (like `localStorage`), logging to the console, fetching data, or setting up subscriptions.</p><p>It replaces the `$: ` label when used to call a function or run a block of code. The code inside an `$effect` will re-run automatically whenever any reactive values it depends on are updated. It runs after the DOM has been updated with the latest changes.</p><p><strong>Svelte 4:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = 0;\n\n  $: {\n    console.log(`The count has changed to: ${count}`);\n    document.title = `Count is ${count}`\n  }\n&lt;/script&gt;</code></pre><p><strong>Svelte 5 with Runes:</strong></p><pre><code class="language-markup">&lt;script&gt;\n  let count = $state(0);\n\n  $effect(() =&gt; {\n    console.log(`The count has changed to: ${count}`);\n    document.title = `Count is ${count}`\n  });\n&lt;/script&gt;</code></pre><p>`$effect` provides a clean and predictable lifecycle for side effects, making it clear which code interacts with the world outside of the component's render logic.</p><h2 id="putting-it-all-together-a-practical-refactoring-example">Putting It All Together: A Practical Refactoring Example</h2><p>Theory is great, but seeing Runes in action is where their value truly clicks. Let's refactor a classic to-do list component from Svelte 4 to the new Svelte 5 syntax to see how these primitives work in concert.</p><h3 id="before-a-to-do-list-in-svelte-4">Before: A To-Do List in Svelte 4</h3><p>Here is a standard, functional to-do list component built with Svelte 4's reactivity model. It uses `let` for state and `$: ` to compute the count of remaining items.</p><pre><code class="language-markup">&lt;!-- TodoList.svelte (Svelte 4) --&gt;\n&lt;script&gt;\n  let todos = [\n    { id: 1, text: 'Learn Svelte', done: true },\n    { id: 2, text: 'Build an app', done: false }\n  ];\n  let newTodoText = '';\n\n  $: remaining = todos.filter(t =&gt; !t.done).length;\n\n  function addTodo() {\n    if (!newTodoText.trim()) return;\n    todos = [...todos, { id: Date.now(), text: newTodoText, done: false }];\n    newTodoText = '';\n  }\n\n  function toggleDone(id) {\n    const todo = todos.find(t =&gt; t.id === id);\n    if (todo) {\n      todo.done = !todo.done;\n      todos = todos; // Assignment required to trigger update\n    }\n  }\n&lt;/script&gt;\n\n&lt;main&gt;\n  &lt;h1&gt;To-Do List&lt;/h1&gt;\n  &lt;h2&gt;{remaining} remaining&lt;/h2&gt;\n\n  &lt;form on:submit|preventDefault={addTodo}&gt;\n    &lt;input bind:value={newTodoText} placeholder=\"What needs to be done?\" /&gt;\n    &lt;button type=\"submit\"&gt;Add&lt;/button&gt;\n  &lt;/form&gt;\n\n  &lt;ul&gt;\n    {#each todos as todo (todo.id)}\n      &lt;li&gt;\n        &lt;input type=\"checkbox\" bind:checked={todo.done} on:change={() =&gt; toggleDone(todo.id)} /&gt;\n        &lt;span style:text-decoration={todo.done ? 'line-through' : 'none'}&gt;\n          {todo.text}\n        &lt;/span&gt;\n      &lt;/li&gt;\n    {/each}\n  &lt;/ul&gt;\n&lt;/main&gt;</code></pre><h3 id="after-the-same-to-do-list-with-runes">After: The Same To-Do List with Runes</h3><p>Now, let's refactor the same component to use Runes. Notice how `$state` makes the state explicit, `$derived` clarifies the computation, and the event handlers can now mutate state directly without needing reassignment tricks.</p><pre><code class="language-markup">&lt;!-- TodoList.svelte (Svelte 5) --&gt;\n&lt;script&gt;\n  let todos = $state([\n    { id: 1, text: 'Learn Svelte 5', done: true },\n    { id: 2, text: 'Build an app with Runes', done: false }\n  ]);\n  let newTodoText = $state('');\n\n  let remaining = $derived(todos.filter(t =&gt; !t.done).length);\n\n  function addTodo() {\n    if (!newTodoText.trim()) return;\n    // We can now just push! No reassignment needed.\n    todos.push({ id: Date.now(), text: newTodoText, done: false });\n    newTodoText = '';\n  }\n  \n  // We can even use an effect to persist to localStorage\n  $effect(() =&gt; {\n    if (typeof window !== 'undefined') {\n      localStorage.setItem('svelte5-todos', JSON.stringify(todos));\n      console.log('Todos saved!');\n    }\n  });\n\n&lt;/script&gt;\n\n&lt;main&gt;\n  &lt;h1&gt;To-Do List&lt;/h1&gt;\n  &lt;!-- Note: derived values are read-only, so we use its value directly --&gt;\n  &lt;h2&gt;{remaining} remaining&lt;/h2&gt;\n\n  &lt;form on:submit|preventDefault={addTodo}&gt;\n    &lt;!-- We bind directly to the stateful value --&gt;\n    &lt;input bind:value={newTodoText} placeholder=\"What needs to be done?\" /&gt;\n    &lt;button type=\"submit\"&gt;Add&lt;/button&gt;\n  &lt;/form&gt;\n\n  &lt;ul&gt;\n    {#each todos as todo (todo.id)}\n      &lt;li&gt;\n        &lt;!-- Direct mutation on change works fine --&gt;\n        &lt;input type=\"checkbox\" bind:checked={todo.done} /&gt;\n        &lt;span style:text-decoration={todo.done ? 'line-through' : 'none'}&gt;\n          {todo.text}\n        &lt;/span&gt;\n      &lt;/li&gt;\n    {/each}\n  &lt;/ul&gt;\n&lt;/main&gt;</code></pre><p>The result is code that is arguably more readable and less prone to reactivity gotchas.</p><h3 id="bonus-building-a-reusable-store-with-runes">Bonus: Building a Reusable Store with Runes</h3><p>Perhaps the most powerful feature of Runes is that they liberate reactivity from `.svelte` files. We can now create complex, reactive logic in plain TypeScript or JavaScript files and import them anywhere. This is a massive win for code organization and reusability.</p><p>Let's create a simple, reusable counter store.</p><p><strong>`counter.store.js`</strong></p><pre><code class="language-javascript">import { $state, $derived } from 'svelte/js';\n\nexport function createCounter(initialCount = 0) {\n  // Create reactive state inside a regular function\n  let count = $state(initialCount);\n  let double = $derived(count * 2);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n\n  // Expose the reactive values and methods\n  return {\n    get count() { return count; },\n    get double() { return double; },\n    increment,\n    decrement\n  };\n}</code></pre><p><strong>`CounterComponent.svelte`</strong></p><pre><code class="language-markup">&lt;script&gt;\n  import { createCounter } from './counter.store.js';\n\n  // Instantiate our store\n  const counter = createCounter(5);\n&lt;/script&gt;\n\n&lt;div&gt;\n  &lt;p&gt;Current count: {counter.count}&lt;/p&gt;\n  &lt;p&gt;Double the count: {counter.double}&lt;/p&gt;\n  &lt;button on:click={counter.increment}&gt;+&lt;/button&gt;\n  &lt;button on:click={counter.decrement}&gt;-&lt;/button&gt;\n&lt;/div&gt;</code></pre><p>This pattern of creating composable, reactive primitives is a true game-changer for Svelte architecture, enabling cleaner separation of concerns and more scalable state management solutions.</p><h2 id="the-bigger-picture-what-runes-mean-for-the-future-of-svelte">The Bigger Picture: What Runes Mean for the Future of Svelte</h2><p>The introduction of Runes is more than a syntax update; it's a strategic move that positions Svelte for the future, addressing long-standing challenges and opening up new possibilities.</p><h3 id="improved-developer-experience-and-tooling">Improved Developer Experience and Tooling</h3><p>Explicit signals make code significantly easier to reason about. There's no more ambiguity about which variables are reactive. This clarity simplifies debugging, as the flow of data is more transparent. This explicitness is also a boon for tooling. Static analysis tools, linters, and IDEs can more reliably understand Svelte code without needing deep integration with the compiler's inner workings, leading to better autocompletion, type-checking with TypeScript, and error detection.</p><h3 id="performance-and-granularity">Performance and Granularity</h3><p>While Svelte has always been known for performance, Runes unlock a new level of optimization. The old reactivity model was largely component-scoped; a change could cause all reactive declarations in a component to be re-evaluated. Runes enable truly fine-grained reactivity. When a `$state` value changes, only the specific `$derived` values and `$effect`s that depend on it are updated. This surgical precision means Svelte can do even less work to update the DOM, resulting in faster and more efficient applications, especially in data-dense interfaces.</p><h3 id="lowering-the-barrier-to-entry">Lowering the Barrier to Entry</h3><p>This might seem counter-intuitive, as Runes add new concepts to learn. However, by adopting a function-based, signal-like model, Svelte aligns more closely with patterns seen in other modern frameworks. A developer coming from React will find `$state`, `$derived`, and `$effect` conceptually similar to `useState`, `useMemo`, and `useEffect`. This shared mental model can actually make it easier for developers from other ecosystems to become productive in Svelte, reducing the framework's 'uniqueness' barrier and broadening its appeal.</p><h2 id="embracing-the-future-your-next-steps-with-svelte-5">Embracing the Future: Your Next Steps with Svelte 5</h2><p>Svelte 5's Runes represent a significant and exciting evolution for the framework. By trading compiler magic for explicit, function-based primitives like `$state`, `$derived`, and `$effect`, Svelte is empowering developers to write more scalable, predictable, and maintainable code. This shift doesn't abandon Svelte's core philosophy of simplicity and performance; it enhances it, providing a more robust foundation for the next generation of web applications.</p><p>This is a positive and necessary step forward, one that addresses the growing pains of complex applications while opening up powerful new patterns for state management. The future of Svelte is explicit, granular, and more powerful than ever.</p><p>Your journey with Svelte 5 starts now. We encourage you to dive in:</p><ul><li><strong>Explore the Svelte 5 Playground:</strong> Get your hands dirty and experiment with Runes in a live environment without any setup.</li><li><strong>Start a side project:</strong> The best way to learn is by building. Try refactoring a small existing project or starting a new one with Runes.</li><li><strong>Consult the official documentation:</strong> As Runes become stable, the official docs will be the ultimate source of truth for advanced use cases and other available Runes.</li></ul><p>Welcome to the next chapter of Svelte.</p><p>Happy coding,<br>&mdash; The ToolShelf Team</p></div><div class="blog-post-navigation"><a href="#" id="prevPostLink" class="nav-link-post prev-post hidden"><i class="fas fa-arrow-left"></i><span>Previous Post</span><span class="nav-post-title"></span></a><a href="#" id="nextPostLink" class="nav-link-post next-post hidden"><span>Next Post</span><span class="nav-post-title"></span><i class="fas fa-arrow-right"></i></a></div><section class="related-posts-section"><h2 class="section-title">Also Read</h2><div class="related-posts-grid"><!-- Related posts will be injected here by JavaScript --></div></section></article></div></main><footer class="app-footer"><div class="footer-content"><div class="footer-main"><div class="footer-logo"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><strong>ToolShelf</strong></div><p class="footer-description">Professional online tools that respect your privacy. Built for developers and professionals worldwide.</p></div><div class="footer-links"><div class="footer-section"><h4>Tools</h4><a href="../../json-formatter/">JSON Formatter</a><a href="../../base64-encoder/">Base64 Encoder</a><a href="../../text-transformer/">Text Transformer</a><a href="../../qr-generator/">QR Generator</a><a href="../../hash-generator/">Hash Generator</a></div><div class="footer-section"><h4>Resources</h4><a href="../../#about">About ToolShelf</a><a href="../../privacy/">Privacy Policy</a><a href="../../terms/">Terms of Use</a><a href="../../faq/">FAQs</a><a href="../../contact/">Contact</a></div><div class="footer-section"><h4>Company</h4><a href="../">Blog</a><a href="../../#about">About Us</a><a href="../../contact/">Contact</a></div></div></div><div class="footer-bottom"><p>© 2025 ToolShelf. All tools work offline and respect your privacy.</p></div></footer><script src="../../shared/config/constants.js"></script><script src="../../shared/js/core/utils.js"></script><script src="../../shared/js/core/analytics.js"></script><script src="../../shared/js/core/app.js"></script><script type="module" src="../js/blog-post.js"></script><!-- Prism.js for Syntax Highlighting --><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script><script>// Minimal Theme Switcher
    (function () {
      let currentTheme = 'light';

      function loadTheme() {
        try {
          const saved = localStorage.getItem('toolshelf-theme');
          if (saved === 'dark' || saved === 'light') {
            currentTheme = saved;
          } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            currentTheme = 'dark';
          }
          document.documentElement.setAttribute('data-theme', currentTheme);
        } catch (e) {
          document.documentElement.setAttribute('data-theme', 'light');
        }
      }

      function toggleTheme() {
        currentTheme = currentTheme === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', currentTheme);
        try {
          localStorage.setItem('toolshelf-theme', currentTheme);
        } catch (e) { }
        updateButton();
      }

      function updateButton() {
        const btn = document.getElementById('themeSwitcher');
        if (btn) {
          const icon = btn.querySelector('i');
          const isDark = currentTheme === 'dark';
          if (icon) {
            icon.className = isDark ? 'fas fa-sun' : 'fas fa-moon';
          }
          btn.title = isDark ? 'Switch to light mode' : 'Switch to dark mode';
          btn.setAttribute('aria-label', btn.title);
        }
      }

      // Load theme immediately
      loadTheme();

      // Setup when DOM is ready
      document.addEventListener('DOMContentLoaded', function () {
        updateButton();
        const btn = document.getElementById('themeSwitcher');
        if (btn) {
          btn.addEventListener('click', toggleTheme);
        }
      });
    })();</script><div id="feedbackWidgetContainer"></div><script type="module">
    import { initFeedbackWidget } from '../../shared/js/core/feedback-widget.js';
    document.addEventListener('DOMContentLoaded', () => {
      initFeedbackWidget('Blog Post: ' + document.title);
    });
  </script></body></html>