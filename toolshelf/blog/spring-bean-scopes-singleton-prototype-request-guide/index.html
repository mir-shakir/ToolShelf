<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Spring Bean Scopes Demystified: Singleton vs. Prototype vs. Request</title><meta name="title" content="Spring Bean Scopes Demystified: Singleton vs. Prototype vs. Request"><meta name="description" content="Master Spring Bean Scopes: Singleton, Prototype, and Request. Learn how memory usage, thread safety, and lifecycle management impact your application's performance."><link rel="canonical" href="https://toolshelf.tech/blog/spring-bean-scopes-singleton-prototype-request-guide/"><meta property="og:type" content="article"><meta property="og:url" content="https://toolshelf.tech/blog/spring-bean-scopes-singleton-prototype-request-guide/"><meta property="og:title" content="Spring Bean Scopes Demystified: Singleton vs. Prototype vs. Request"><meta property="og:description" content="Master Spring Bean Scopes: Singleton, Prototype, and Request. Learn how memory usage, thread safety, and lifecycle management impact your application's performance."><meta property="og:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/e74f988a-7363-4a7f-811f-f66e616c46d3_blog_header.png"><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://toolshelf.tech/blog/spring-bean-scopes-singleton-prototype-request-guide/"><meta property="twitter:title" content="Spring Bean Scopes Demystified: Singleton vs. Prototype vs. Request"><meta property="twitter:description" content="Master Spring Bean Scopes: Singleton, Prototype, and Request. Learn how memory usage, thread safety, and lifecycle management impact your application's performance."><meta property="twitter:image" content="https://dszufhozbgwxgoanxljq.supabase.co/storage/v1/object/public/generations/2a6977e2-cb1b-4027-ab46-b33c5c0a7ddc/e74f988a-7363-4a7f-811f-f66e616c46d3_blog_header.png"><link rel="icon" type="image/x-icon" href="../../favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="../../favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="../../favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="../../apple-touch-icon.png"><link rel="manifest" href="../../manifest.json"><meta name="theme-color" content="#3b82f6"><link rel="stylesheet" href="../../shared/css/variables.css"><link rel="stylesheet" href="../../shared/css/base.css"><link rel="stylesheet" href="../../shared/css/layout.css"><link rel="stylesheet" href="../css/blog.css"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Fira+Code&display=swap" rel="stylesheet"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css"></head><body><div class="scroll-progress-bar"></div><header class="app-header"><div class="header-container"><div class="logo-section"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><a href="../../" class="logo-text">ToolShelf</a></div><nav class="main-nav"><a href="../../" class="nav-link">Home</a><a href="../../#tools" class="nav-link">Tools</a><a href="../" class="nav-link active">Blog</a><a href="../../#about" class="nav-link">About</a></nav><div class="header-actions"><button class="theme-switcher-btn" id="themeSwitcher" title="Switch to dark mode" aria-label="Switch to dark mode"><i class="fas fa-moon"></i></button></div></div></header><main><div class="blog-post-container"><aside class="toc-container" id="tocContainer"><h3>Table of Contents</h3><ul class="toc-list" id="tocList"></ul></aside><article class="blog-post-article"><header class="blog-post-header"><h1 class="blog-post-title">Spring Bean Scopes Demystified: Singleton vs. Prototype vs. Request</h1><div class="blog-post-meta"><span>By ToolShelf Expert Technical Writer</span><span><i class="fas fa-calendar-alt"></i> January 24, 2026</span><span><i class="fas fa-clock"></i> 8 min read</span></div><div class="blog-post-tags"><span class="tag-badge">Spring Boot</span><span class="tag-badge">Java</span><span class="tag-badge">Backend</span><span class="tag-badge">Software Architecture</span><span class="tag-badge">Best Practices</span></div></header><div class="blog-post-content" id="articleContent"><p>Spring’s Dependency Injection (DI) often feels like magic. You annotate a class with <code>@Component</code>, add an <code>@Autowired</code> field elsewhere, and suddenly everything works. However, treating the IoC (Inversion of Control) container as a black box is dangerous. Misunderstanding how and when your beans are created—specifically their scopes—is a primary cause of nasty production bugs, ranging from subtle race conditions to catastrophic memory leaks.</p><p>In the Spring ecosystem, a "Bean Scope" defines more than just visibility; it dictates the lifecycle of a bean instance managed by the container. It controls how long the bean lives, how many instances exist, and when they are discarded.</p><p>In this guide, we will dissect the three most critical scopes for backend developers: <strong>Singleton</strong>, <strong>Prototype</strong>, and <strong>Request</strong>. We will compare them not just syntactically, but through the lens of memory usage and thread safety to ensure your applications remain robust under load.</p><h2 id="the-default-singleton-scope">The Default: Singleton Scope</h2><p>If you do not explicitly define a scope, Spring uses <strong>Singleton</strong>. This is the bread and butter of Spring Boot applications.</p><p>It is vital to distinguish the Spring Singleton from the "Gang of Four" (GoF) Singleton pattern. The GoF pattern ensures one instance of a class exists per <em>ClassLoader</em>. The Spring Singleton, conversely, ensures one instance exists per <em>IoC Container</em> (ApplicationContext). While these often overlap in practice, the distinction matters in complex, multi-module setups.</p><h3 id="memory-implications">Memory Implications</h3><p>Spring defaults to Singleton for one reason: <strong>Efficiency</strong>. When the container starts, it creates the bean instance once, caches it, and injects that same reference everywhere it is needed. This minimizes garbage collection pressure and initialization overhead, making it ideal for the majority of your beans.</p><h3 id="the-critical-warning-thread-safety">The Critical Warning: Thread Safety</h3><p>Because a single instance is shared across your entire application, <strong>Singleton beans must be stateless</strong>.</p><p>Consider a scenario where a Singleton service handles incoming web requests. If 100 users hit your endpoint simultaneously, 100 threads will access the <em>exact same instance</em> of that bean. If you store mutable state (like a user's ID or a calculation result) in a class-level field, those threads will overwrite each other's data. This is a classic race condition.</p><h3 id="when-to-use-singleton">When to Use</h3><p>Use Singleton scope for 95% of your application components, specifically:</p><ul><li><strong>Service Layers:</strong> Where logic is executed but state is not retained.</li><li><strong>DAOs / Repositories:</strong> Where database connections are managed (usually via a thread-safe connection pool).</li><li><strong>Utility Classes:</strong> Helpers that perform transformations.</li></ul><h2 id="the-maverick-prototype-scope">The Maverick: Prototype Scope</h2><p>While Singleton is about sharing, <strong>Prototype</strong> scope is about isolation. When you define a bean with <code>@Scope("prototype")</code>, the IoC container creates a brand new instance of the bean every single time it is requested—whether that request comes from <code>context.getBean()</code> or via dependency injection into another bean.</p><h3 id="lifecycle-differences">Lifecycle Differences</h3><p>Prototype scope behaves differently regarding lifecycle management. For Singletons, Spring manages the full lifecycle: creation, initialization, and destruction (<code>@PreDestroy</code>).</p><p>However, for Prototypes, Spring hands the bean over to the client and then forgets about it. <strong>Spring does not manage the complete lifecycle of a prototype bean.</strong> The container instantiates, configures, and assembles the prototype, but destruction callbacks are <em>not</em> called. It is the responsibility of the client code to clean up prototype-scoped objects, which can lead to memory leaks if not handled correctly.</p><h3 id="memory-implications-prototype">Memory Implications</h3><p>Prototype scope incurs high overhead. Instantiating a complex object graph for every injection point is expensive regarding CPU cycles and memory allocation. Overusing prototypes can lead to significant garbage collection pressure, as short-lived objects churn through the heap.</p><h3 id="when-to-use-prototype">When to Use</h3><p>Prototype is rarely needed in standard web development, but it shines in specific scenarios:</p><ul><li><strong>Stateful Beans (Non-Web):</strong> If you need a bean to hold state for a specific background process that isn't tied to an HTTP request.</li><li><strong>Thread Safety by Isolation:</strong> If a class is not thread-safe and cannot be refactored, injecting a new instance for every thread can act as a workaround (though this is often a code smell).</li></ul><h2 id="the-web-specialist-request-scope">The Web Specialist: Request Scope</h2><p>In the context of Spring MVC or Spring WebFlux, we gain access to "Web-Aware" scopes. The most prominent of these is <strong>Request</strong> scope.</p><p>Annotating a bean with <code>@RequestScope</code> (or <code>@Scope(value = WebApplicationContext.SCOPE_REQUEST)</code>) tells Spring: "Create a new instance of this bean for a single HTTP request, and destroy it when the request completes."</p><h3 id="use-case-request-isolation">Use Case: Request Isolation</h3><p>This is the standard solution for storing user-specific data that needs to be accessible across different layers of your application during a single transaction, without passing parameters through every method signature.</p><p>Common examples include:</p><ul><li><strong>User Context:</strong> Storing the authenticated user's ID and roles.</li><li><strong>Auditing Data:</strong> Tracking correlation IDs for logging.</li><li><strong>Auth Tokens:</strong> Holding JWTs for downstream API calls.</li></ul><h3 id="comparison-with-prototype">Comparison with Prototype</h3><p>Developers often confuse Prototype and Request scopes. The distinction is subtle but important:</p><ul><li><strong>Prototype:</strong> Creates a new bean per <em>injection point</em>. If Service A and Service B both inject a Prototype bean, they get two different instances.</li><li><strong>Request:</strong> Creates a new bean per <em>HTTP cycle</em>. If Service A and Service B both inject a Request-scoped bean during the <em>same</em> HTTP request, they share the <em>same</em> instance. This allows them to share state (like the current user) for that specific transaction.</li></ul><h2 id="the-gotcha-injecting-scoped-beans-into-singletons">The "Gotcha": Injecting Scoped Beans into Singletons</h2><p>Here lies the most common interview question and production bug regarding scopes: <strong>What happens when you inject a Request-scoped bean into a Singleton Service?</strong></p><h3 id="the-problem">The Problem</h3><p>Remember, a Singleton is created <em>once</em> at application startup. At that moment, Spring attempts to inject its dependencies. If it injects a Request-scoped bean directly, it would inject an instance created at startup. That instance would then be effectively trapped inside the Singleton forever. Every subsequent web request would use that same, stale bean (or fail because no active request existed at startup).</p><h3 id="the-solution-scoped-proxies">The Solution: Scoped Proxies</h3><p>To solve this, Spring uses a <strong>Scoped Proxy</strong>.</p><p>When you define a request-scoped bean, you should usually configure it like this:</p><pre><code class="language-java">@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserContext {
    // ...
}</code></pre><p><em>(Note: <code>@RequestScope</code> is a composed annotation that applies <code>proxyMode = ScopedProxyMode.TARGET_CLASS</code> automatically.)</em></p><h3 id="technical-explanation">Technical Explanation</h3><p>When <code>proxyMode</code> is active, Spring does not inject the actual <code>UserContext</code> instance into your Singleton service. Instead, it injects a <strong>CGLIB Proxy</strong> (a subclass generated at runtime).</p><p>When your Singleton service calls <code>userContext.getUserId()</code>, it is actually calling the proxy. The proxy then performs a lookup to fetch the real <code>UserContext</code> instance bound to the current thread's HTTP request and delegates the method call to it. This ensures thread safety and correct scoping, even inside a Singleton.</p><h3 id="alternative-approach">Alternative</h3><p>If you prefer to avoid proxies, you can inject an <code>ObjectFactory<UserContext></code> or <code>Provider<UserContext></code> and call <code>.getObject()</code> whenever you need the instance. This performs a lazy lookup, though proxies are generally cleaner to read.</p><h2 id="summary-choosing-the-right-scope">Summary: Choosing the Right Scope</h2><p>Understanding scopes is about balancing memory efficiency with thread safety. Here is your mental model for decision making:</p><div class="table-wrapper"><table><thead><tr><th>Scope</th><th>Lifecycle</th><th>Thread Safety Strategy</th><th>Ideal Use Case</th></tr></thead><tbody><tr><td><strong>Singleton</strong></td><td>One per Container</td><td>Must be stateless</td><td>Services, DAOs, Utilities</td></tr><tr><td><strong>Prototype</strong></td><td>One per Injection</td><td>Safe via isolation (unique instances)</td><td>Stateful non-web beans, heavy calculation objects</td></tr><tr><td><strong>Request</strong></td><td>One per HTTP Request</td><td>Safe via isolation (per request)</td><td>User context, Correlation IDs, Auth tokens</td></tr></tbody></table></div><h3 id="final-advice">Final Advice</h3><ol><li><strong>Stick to Singleton</strong> for 95% of your beans. It is the most memory-efficient.</li><li><strong>Use Request Scope</strong> when you need to carry state throughout an HTTP transaction.</li><li><strong>Use Prototype sparingly</strong>, as it incurs performance penalties and requires manual lifecycle management if resources need cleanup.</li></ol><p>Take a moment to audit your current codebase. Look for Singleton beans (the default) that hold mutable fields. If you find them, you likely have a hidden concurrency bug waiting to happen. Refactor them to be stateless or move that state into a Request-scoped bean.</p></div><div class="blog-post-navigation"><a href="#" id="prevPostLink" class="nav-link-post prev-post hidden"><i class="fas fa-arrow-left"></i><span>Previous Post</span><span class="nav-post-title"></span></a><a href="#" id="nextPostLink" class="nav-link-post next-post hidden"><span>Next Post</span><span class="nav-post-title"></span><i class="fas fa-arrow-right"></i></a></div><section class="related-posts-section"><h2 class="section-title">Also Read</h2><div class="related-posts-grid"><!-- Related posts will be injected here by JavaScript --></div></section></article></div></main><footer class="app-footer"><div class="footer-content"><div class="footer-main"><div class="footer-logo"><div class="logo-icon"><i class="fas fa-toolbox"></i></div><strong>ToolShelf</strong></div><p class="footer-description">Professional online tools that respect your privacy. Built for developers and professionals worldwide.</p></div><div class="footer-links"><div class="footer-section"><h4>Tools</h4><a href="../../json-formatter/">JSON Formatter</a><a href="../../base64-encoder/">Base64 Encoder</a><a href="../../text-transformer/">Text Transformer</a><a href="../../qr-generator/">QR Generator</a><a href="../../hash-generator/">Hash Generator</a></div><div class="footer-section"><h4>Resources</h4><a href="../../#about">About ToolShelf</a><a href="../../privacy/">Privacy Policy</a><a href="../../terms/">Terms of Use</a><a href="../../faq/">FAQs</a><a href="../../contact/">Contact</a></div><div class="footer-section"><h4>Company</h4><a href="../">Blog</a><a href="../../#about">About Us</a><a href="../../contact/">Contact</a></div></div></div><div class="footer-bottom"><p>© 2025 ToolShelf. All tools work offline and respect your privacy.</p></div></footer><script src="../../shared/config/constants.js"></script><script src="../../shared/js/core/utils.js"></script><script src="../../shared/js/core/analytics.js"></script><script src="../../shared/js/core/app.js"></script><script type="module" src="../js/blog-post.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-java.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-css.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script><script>(function(){let currentTheme='light';function loadTheme(){try{const saved=localStorage.getItem('toolshelf-theme');if(saved==='dark'||saved==='light'){currentTheme=saved;}else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme: dark)').matches){currentTheme='dark';}document.documentElement.setAttribute('data-theme',currentTheme);}catch(e){document.documentElement.setAttribute('data-theme','light');}}function toggleTheme(){currentTheme=currentTheme==='light'?'dark':'light';document.documentElement.setAttribute('data-theme',currentTheme);try{localStorage.setItem('toolshelf-theme',currentTheme);}catch(e){}updateButton();}function updateButton(){const btn=document.getElementById('themeSwitcher');if(btn){const icon=btn.querySelector('i');const isDark=currentTheme==='dark';if(icon){icon.className=isDark?'fas fa-sun':'fas fa-moon';}btn.title=isDark?'Switch to light mode':'Switch to dark mode';btn.setAttribute('aria-label',btn.title);}}loadTheme();document.addEventListener('DOMContentLoaded',function(){updateButton();const btn=document.getElementById('themeSwitcher');if(btn){btn.addEventListener('click',toggleTheme);}});})();</script><div id="feedbackWidgetContainer"></div><script type="module">import { initFeedbackWidget } from '../../shared/js/core/feedback-widget.js';document.addEventListener('DOMContentLoaded', () => {initFeedbackWidget('Blog Post: ' + document.title);});</script></body></html>